20: 
电话区号码查询初始化功能 bug 修复：
描述：istanbul 登录应用中，电话号码选择框，会根据ip查询所属国家，但是由于系统对于部分地区与国家没有开放，
因此需要进行过滤。由于系统在开发的时候，没有考虑过滤，从而导致电话区号码初始化错误；
方案：由于根据ip查询到的国家没有过滤导致问题。目前处理的方法直接写在istanbul中，其实这部分功能应该共用起来，放到sian中更加合适；如果第二次遇到这种修改的时候， 就统一迁移到sian中 ；

测试反馈 bug 未修复成功问题：
描述：本地由于没有测试（由于对代码足盲目自信），所以跟踪了下测试的问题。 
分析：
1 在过滤过程调用的rpc服务查询地区信息使用了java缓存，缓存的更新采用了分布式job，这样带来的问题是，数据库修改的信息，无法更新到缓存中，因为job没有调用；
公司的job调用，测试还不熟悉，很多人不会使用；
方法：让测试直接重启sian应用刷新缓存，问题解决；

fci项目中采用vue，跳转页面报错：
请采用this.$router.push('real_path')

LRUCache实现：
知乎作者一篇lrucahe实现，采用自己实现的双向链表和hashmap结合。作者觉得linkedhashmap无法实现，但是在看dubbo的源码的时候发现，dubbo中的lrucache就是以linkedhashmap实现的
于是了解一下原理：linkedhashmap提供构造函数传入accessorder，如果传入值为true，hashmap会在插入时检测是否达到map最大容量， 如果容量达到最大值，则将列表头部的最近最少访问
节点删除，从而实现lru
感悟：在写代码时，切勿想当然认为自己的是最好的。

redis Lru实现：
redis采用的lru为了避免构造的数据结构占用内存问题，使用随机算法选择key，进行检查最老的元素，从而进行释放。
感悟：在实际项目中，根据实际情况选择合适的策略，不一定要完整实现一个比较耗时或者耗内存的算法。



21：
参加头条面试：
部门数据平台部门，数据平台主要考察数据库的复制、redis内存问题、数据处理算法问题。
回答的不好， 继续努力吧。

22： 
docker中想要自定义网络，从而实现容器可以像宿主机一样可以局域网访问。
	在考虑这个问题的时候，发现对网络知识不是很理解，顺便复习下计算机网络的知识：https://www.cnblogs.com/maybe2030/p/4781555.html#_label2
	总结如下：
	7层网络协议: 应用层、表示层、会话层、传输层、网络层、数据链路层、物理层
	4层协议：会话层（如http， 数据传输单位为报文）、传输层（tcp 负责流控、查错管理）、网络层（ip负责路由与路由器交互）、网络接口层（数据传输单位为帧）
	arp： address resolution protocal 子网内广播，根据ip查找目标主机的mac地址， 并且本地缓存
	tcp 三次握手：
		client  --- syn ---> server
		client <--- syn + ack --- server
		client  --- ack ---> server
	tcp为啥不能二次握手：
		因为如果server的回复丢失，server将等待client的请求，从而造成资源浪费
	tcp 四次端口：
		client --- fin ---> server
		client <--- ack --- server
		client <--- fin --- server
		client --- ack ---> server
	原因：双方是平等的链接，互相确认关闭
	tcp udp: tcp是有连接的，可靠地字节流服务，udp是无连接的，不可靠的数据服务
	nat：私有地址转换成广域网ip的技术
	get post 区别：请求参数位置不同，是否幂等、传输数据不同get：2kb post：不受限制；
	gateway： 路由器的ip地址
在仔细考虑网络的问题后，本地无法与容器通信是不行的，本地需要容器中的服务时，就无法完成请求
	分析：需要容器内网络和本地网路通信；
	方案：宿主机安装docker，创建自定义网络；
		  提供ip导入功能，设置哪些ip可以用于容器分配；
		  容器启动，指定自定义网络，并且指定ip，占用ip；容器删除，释放ip；

25: 
计算机网络问题
	在解决docker网络的问题的过程中， 我发现自己对linux真的是很不了解，网卡、网桥、虚拟网卡他们如何配合工作，一点不了解。我觉得我需要重新将这块的学习一遍。
	
26:
今天把虚拟机又弄挂了一次：
	我想在56.28上搭建和测试环境一样的docker网络环境：容器可以固定和宿主机同子网的ip。
	步骤：
	1 我创建了一个docker network， 
	2 把56.28/24ip设置到对应的网桥上br-e258b14d7605， 
	3 把ens160网卡上的ip删除， 
	4 将ens160添加到br-e258b14d7605, 
	5 最后设置网桥的默认网关 192.168.56.3
	由于是远程操作linux，所以网络一定故障，就无法操作，后来联系运维恢复网络才解决，但是他们也不会用bridge模式，所以这个问题还是没有解决，心累
	运维要么把机器的权限放到业务线，要么很懂linux，比较懂网络如何配置，说到底还是公司整体技术水平不行； 
先设计下ip管理功能：
	1 导入ip功能，由于我们的ip比较分散，所以通过文本导入方式，选择文件，逐行导入
	2 表结构：id ip status
	3 选择ip功能，简单方式，通过db乐观锁直接根据状态预锁定ip，启用任务，超过10分钟预锁定状态的，释放
	4 根据docker的网络子网，选择ip，预锁定，容器创建，锁定ip，容器释放，释放ip

27:
王涛的面试题汇总：
HashMap实现原理：
	java8中在原有的 数组+链表的结构上做了改进，采用数组+链表+红黑树 当位桶的链表程度超过8则转换成红黑树，用于实现logn时间长度的查找
	在计算取模运算的时候采用(n-1) & hash 效率高于hash % (n-1)
	详细分析可以参考：https://www.cnblogs.com/xiaoxi/p/7233201.html
并发情况下资源共享问题：
	需要把握几个要点：削峰、分区、排队、写一致性 
	例如在做秒杀系统时：
		削峰：使用图形验证码限流、随机拒绝请求等操作；
		分区：将热点产品（共享资源）独立出来，例如库存可以分区分成不同的商品
		排队：同一个分区排队处理，
		写一致性：读写分离、读不做校验、写作强校验 
mysql事务问题：
	innodb的默认采用行锁，但是行锁是在索引上添加锁实现的，如果没有按照索引条件，那么会采用表锁，但是更新操作一般都是根据id来更新，所以正常都是行锁； 
    4种隔离级别： read-uncommited read-committed repetable-read(默认，可以查看select @@tx_isolation) serialable
	7种传播行为： required（加入事务或者新事务） support（加入事务或者非事务） mandotary（必须有事务） new（挂起原事务，新建新事务）never（必须非事务） not-support（挂起事务，非事务执行） nest(嵌套事务) 
Session和cookie的区别，这两者的作用：
	cookie: 是服务器存储在本地的小片文本，用于记录状态。以key/value的形式存储，有2种类：设置失效时间-permenent-存储在磁盘上；不设置时间-transient-存储在内存中-浏览器关闭删除
	session:服务器在接收到请求时生成session_id，可以将需要共享的信息放到session中，从而实现会话会话共享，session中可以存储任何java对象，通过session_id和cookie进行关联
	区别：位置不同，cookie浏览器session服务端、数据类型不同
如何实现单点登录系统: 
    跨域情况：
	通过跳转到sso系统实现登录并生成ticket；
    应用拿到ticket访问sso校验ticket，通过，写入自己的token和cookie
	同域情况：
	cookie写入一级域名下，实现cookie共享、使用session共享方案实现session共享，例如spring-sesion或者自己通过redis实现session共享； 
http和https的区别:
    http主要版本分为1.1 2，http1.1相对于1.0实现多路复用tcp通道，多http请求共用tcp连接，2从2015年开始逐渐形成主流；http是无状态的，所以用户会话需要借助cookie/session来实现；
    另外http1.1之后提供默认持久连接，从而实现多路复用tcp通道；
    https基于http协议，使用ssl实现信息加密身份认证、数据完整性保护。其过程如下：
    client --- 访问 ---> server
    client <--- ca证书 ---- server 证书就是公钥
    client ---- 公钥加密私钥
    client ---- 私钥加密请求---> server 
                私钥解密客户端的秘钥 ---server
	        私钥加密response ----server
    client <--- response--- server
    区别：https需要向ca申请，需要另外的费用、申请需要绑定域名ip、连接缓存不如http搞笑、流量耗电都高于http。建议无用户信息的页面可以采用http连接；
    参考：https://blog.csdn.net/xiaoming100001/article/details/81109617
悲观锁和乐观锁，分别用这两种锁设计数据库：
    乐观锁：通过给表加version，在更新的时候对比version实现更新，如果更新数据条数为0，说明数据已经失效，可以直接拒绝请求，让请求端重新请求； 
    悲观锁：在读取数据的时候则认为该数据会冲突，通过select for update 加锁实现锁定
负载均衡的策略：
    轮询：实现简单，但是对于长连接无法保持在同一台机器上
    随机：实现简单，但问题和轮询一致；
    加权随机：比随机优势在于可以根据服务器性能进行加权
    最小连接数：需要维护服务器的连接链表
    最小响应时间：
    最小cpu负载：该项不是很常用，因为cpu负载往往不能反映服务器的性能，因为更多的消耗在于io
    hash：解决了同源请求单机处理，但是无法解决宕机带来的问题
    hash一致性：在节点少的情况下通过引入虚拟节点，使得请求均匀，解决了宕机问题，比较常用，java中也有第三方库实现的hash一致性算法，在信息发送通道选择时
    也常被使用
数据库连接不足，可能造成的原因：
    数据库角度来看：数据库最大连接数和数据库当前连接数数量会影响；检查这2项数据确定问题原因，确定初步原因；
    可能的原因：如果过多事务时间较长，并发请求书较高，会导致连接数过大。需要检查事务开启的时间是否正确，并且数据库的最大连接数设置是否合理；
    扩展：client请求出错，服务器会中断请求，次数过多，会导致拒绝该client的请求
分布式系统中的session存储问题
    应用服务器中存储，并且进行服务器之间同步。缺点：必须依赖应用服务器的共享能力，例如应用服务器之间不能够共享，session中的对象如果过大，带来巨大的序列         化以及同步复制的消耗，同时广播复制，也会带来网络瓶颈；
    redis共享：采用redis集群（防止单机故障问题）实现session共享是比较主流的方式，应用服务器在本地获取session没有取到的情况下，会从redis中获取，获取到
    应用服务器的session会根究缓存策略存活一定时间，只有对session的修改才会重新写入redis；
设计一个秒杀系统：
    秒杀系统核心要素：限流、隔离、分区、排队、写一致性；从前到后降低流量处理
    限流与削峰：前端页面缓存，将前端页面实现动静分离，提取页面上的动态数据在服务端或者客户端请求数据，与静态页面进行组合，尽可能将数据cache到缓存中；
        可以提供验证码削峰，将大量并发数据分散到2秒左右；请求量大的情况下，可以随机拒绝部分请求；
    隔离：提供新域名从而便于对秒杀系统进行扩容，流量分散到新的服务器集群中；
    分区：对于同一商品拆分，将库存数据分区，对请求hash，扣减不同商品的库存；
    排队：使用队列，将请求放入队列，异步处理，提升请求的响应速度；
    分区：对于同一商品拆分，将库存数据分区，对请求hash，扣减不同商品的库存；
    分区：对于同一商品拆分，将库存数据分区，对请求hash，扣减不同商品的库存；
    写一致性：对于商品库存的查询可以强求一致性，只在实际扣减时进行一致性校验；
Redis是单线程还是多线程的？Redis可支持的最大并发是多少？
     redis处理网络请求的模块是单线程，并不是说redis全是单线程，对于读、些、链接、断开全部采用epoll+事件的方式，实现io多路复用，提升性能； 
	 redis最大连接数默认是1w，但是由于处理网络连接是单线程处理，所以一般如果连接数过大，带来的往往是cpu的瓶颈；
	 redis相对于memcache的优势：有丰富的类型（string/list/set/zset/hash）、redis可以持久化数据、value最大可以达到1g memcache最大达到1m
	 redis内存回收策略：
	 过期lru、过期ttl、过期随机、全集lru、全集随机、禁止
如何实现分布式锁：
    redis实现代码设计：
	    lock: 
		1 int status = setnx(key, current_time + expire_time) status==1,则成功否则进入步骤2
		2 old_time = get(key, "0") old_time > current_time 失败，否则进入3
		3 new_time = current_time + expire_time, old_time_2 = getset(key, new_time)  old_time == old_time2 则成功，否则获取失败
		unlock: 
		1 获取当前 value = get(key, '0') 如果 value > current_time 进入2
		2 del(key)
		但是这样实现的redis锁是不可重入的，另外分布式专家对redisson分布式锁提出过质疑，因此在安全要求较高的领域可以考虑使用zk锁；
		https://mp.weixin.qq.com/s/1bPLk_VZhZ0QYNZS8LkviA
		https://www.cnblogs.com/seesun2012/p/9214653.html
	 zookeeper实现代码设计：
	    1 在zookeeper一个普通节点parent下创建临时顺序节点；
		2 获取parent下的节点列表； 
		3 判断自己是否是第一个节点，是则获取锁成功，否则进入步骤4
		4 查找前一个节点，读锁查找前一个写节点，写锁查找前一个节点
		5 在前一个节点上监听，节点被删除，当前线程获得锁 ； 
		分析： 
		该锁性能弱于redis，但是可靠性更加高，是一种读写锁、不可重入锁； 
	db实现（性能瓶颈不建议使用）:
	    1、数据库的乐观锁；
		2、数据库的一行记录；
Jvm内存结构如何划分？哪些是线程共享的区域，哪些是线程独占的区域
    线程私有：程序计数器、虚拟机栈、本地方法栈；
	线程共享：方法区（以及运行时常量池）、堆、直接内存；
死锁是如何产生的？如何避免死锁？
    分析：有资源a、b，线程x、y，线程x持有a，并申请b的锁，y相反，形成死锁； 
	避免：对资源顺序加锁
Redis的内存穿透是什么？如何避免？
    含义：缓存不命中，导致数据库查询特别大，容易对数据库的性能产生影响；
	避免：可以有多种方案，如：采用存储空字符串，并且设置过期时间，这种方式多产生key，对redis内存不友好，也容易被攻击；bloomfilter，将有效值的id存入Bloomfilter，进行前置校验；
对敏捷开发的理解？
    理解：这是一种鼓励沟通、团队合作、与客户合作、拥抱变化的开发模式； 
wait和sleep的区别？
    区别： sleep是thread的方法、wait是object的方法；
	sleep不会释放对象的锁、wait会释放对象锁，进入对象的等待区
	sleep和wait都是可以被中断，抛出ire， 但是wait还可以被notify，从而进行对象锁获取准备。
哪些场景下需要用到MQ？
    异步处理系统、应用解耦、高并发系统的削峰、日志系统、通信
说一下springMVC的请求流程？
    servlet dispatcher分发请求，处理映射器找到对应的handler，请求适配器使用handler处理并且返回modelandview，视图解析器解析出view，进行视图渲染，最后返回response响应； 
B+树和B树有什么区别？
    b+树非叶子节点不存储数据，只作为索引用于导航，非叶子节点占用内存更小，便于内存存储更多的索引，
	b+树采用链表结构将叶子节点相连，加以提升遍历速度，并且增加相关数据的缓存命中率； 
	b数由于非叶子节点中存储实际数据，因此可能数据路径更短，访问更加迅速
	详细分析：https://www.cnblogs.com/vincently/p/4526560.html
单例模式怎么写？应用场景有哪些？其他的设计模式的应用场景又有哪些？
    简单的写法
	public final static singletonInstance = new Object(); 缺点：类加载的时候初始化，可能带来没比要的开销 
	double check写法：
	注意：构造函数需要私有化，这种模式在一定情况下由于new对象，先分配内存后对象初始化，因此可能会导致一个线程将单例分配空间后，但是初始化未完成，造成另一个线程使用单例出错。
	public static Object getInstance() { 
	    if (singletonInstance != null) {
		    return singletonInstance; 
		}
		synchronize (TestClass.class) {
		    if (null == singletonInstance) {
			    singletonInstance = new TestClass();
			}
		}
		return singletonInstance;
	}
	静态内部类：
	class Test {
	    private Test() {}
		private static TestHelper {
		    static singletonInstance = new Test();
		}
		
	    public static getInstance() {
		    return TestHelper.singletonInstance;
		}
	}
	应用场景：
	在应用内，只想有一份实例，资源共享的情况下，避免由于资源操作时导致的性能或损耗等如日志文件、应用配置；资源控制，单例模式可以更好的控制资源，如线程池；
	其他设计模式：
	23种设计模式的设计原则：开闭原则、里式替换、依赖倒转、接口隔离、最小知道、合成复用
	设计模式分成三大类：
	创建型（5种）：工厂、抽象工厂、单例、原型、建造者
	     工厂模式：对于需要生产很多产品，这些产品拥有相同的接口时采用；
		工厂模式分为普通工厂和静态工厂，区别是是否需要构造 工厂实例；
		抽象工厂：由于涉及模式中的开闭原则，可以在单纯增加工厂实现，实现扩展；
		单例：在资源共享、资源控制的情况下可以使用，以减小资源消耗； 
		建造者模式：构造多个实例组合起来，对外提供工厂模式；
		原型模式：从一个对象copy生成新对象的，这种方式实现对原有对象的保护，当然建立在深拷贝的基础之上； 
	适配型（7种）：适配器、
	    适配器：类适配器【将类包装成满足特定接口】、对象适配器【将对象转换成满足特定接口】、接口适配器【通过抽象类实现接口，从而现实子类不需要实现全部接口方法】，使用场景当有动机修改一个已经投产的接口时，可以采用；
		
		
解释rpc的工作原理	
（4）Kafka有什么特点？
（5）线程都有哪些状态？各个状态间是如何转换的？线程的方法怎么用？
yield()，join()等
（6）zk的负责均衡策略有哪些？是怎样实现负载均衡的
（7）线程池的核心参数有哪些？逐个线程进来是怎么处理的？
（8）zk有什么特性？
（9）说一说redis缓存穿透和缓存雪崩是什么意思？如何避免？
（10）Java8比起java7有什么新的特性？
（11）如何结束一个线程？

4.饿了么
电话面试：
（1）Hashmap在并发情况下为什么会出现死锁（扩展时）？
（2）Lock和synchronized的区别是什么？Lock的哪些特性是synchronized没有的？
（3）分布式服务治理框架设计时需要考虑哪些东西？
（4）ConcurrentHashMap和hashtable的区别是什么？
（5）创建线程池有哪些方式？
（6）分布式系统中，某几台机器cpu占用率很高，如何排查问题？
（7）是不是分段锁是什么意思？
（8）简单说一下广播事件是什么？
（9）Jvm的垃圾回收分为几代？新生代又怎么划分？哪些对象可以作为可达性分析算法的根节点？
（10）Jvm的持久代是在堆上还是在方法区？
（11）Zookeeper挂掉，整个分布式系统会不会挂掉？
5.拼多多
（1）redis内存满的时候，如何清除最近很少使用的key？
（2）有一个10G的文件，每行记录一个关键词，假设很很多关键词在文件中是重复的。现在有一个内存2G，磁盘很大的电脑。如何统计出现次数最多的前10的关键词及其在文件中出现的次数？
（3）假设有10个整型的数组，如何新启10个线程，分别计算每个数组中数字的总和，然后在计算10个数组总的和？
（4）Java中多线程的包下有哪些类？future和task如何使用？
（5）进程和线程的区别是什么？进程间是如何通信的？
（6）有100有序的整数，如何随机地打乱顺序（类似于扑克牌洗牌的操作）？
6.哈啰出行
（1）分布式锁的代码实现？
（2）ArrayList的代码实现？
（3）算法：基于用户定位找出距离用户最近的5家酒店；
（4）画一下美团点餐的技术架构。
7.安心记加班
（1）http转netty；
（2）各种中间件和CAP定理是如何对应的（占据了CAP中的哪些）？
8.小黑鱼
（1）Kafka中，如果消息的消费者消费失败，后续如何处理？会不会因此导致消息阻塞？
（2）调用system.gc()方法，会立即执行垃圾fullGC吗？
（3）多个线程操作hashMap会有什么现象？
kafka的storm原理与应用
Disruptor并发框架的原理
java实现事件中心

28 
fci系统ip模块开发：
	具有批量预占功能，一个部署任务所需要的ip数量可以计算出来，可以进行批量预占ip，将预占ip存储在concurrentlinkedlist中用于方便获取
	容器创建后，ip被锁定，记录需要锁定的ip
	增加ip任务，扫描预占时间超过10分钟的ip，并进行释放；
	
29
    线上账号模块存在一定的bug修改；
	