20: 
电话区号码查询初始化功能 bug 修复：
描述：istanbul 登录应用中，电话号码选择框，会根据ip查询所属国家，但是由于系统对于部分地区与国家没有开放，
因此需要进行过滤。由于系统在开发的时候，没有考虑过滤，从而导致电话区号码初始化错误；
方案：由于根据ip查询到的国家没有过滤导致问题。目前处理的方法直接写在istanbul中，其实这部分功能应该共用起来，放到sian中更加合适；如果第二次遇到这种修改的时候， 就统一迁移到sian中 ；

测试反馈 bug 未修复成功问题：
描述：本地由于没有测试（由于对代码足盲目自信），所以跟踪了下测试的问题。 
分析：
1 在过滤过程调用的rpc服务查询地区信息使用了java缓存，缓存的更新采用了分布式job，这样带来的问题是，数据库修改的信息，无法更新到缓存中，因为job没有调用；
公司的job调用，测试还不熟悉，很多人不会使用；
方法：让测试直接重启sian应用刷新缓存，问题解决；

fci项目中采用vue，跳转页面报错：
请采用this.$router.push('real_path')

LRUCache实现：
知乎作者一篇lrucahe实现，采用自己实现的双向链表和hashmap结合。作者觉得linkedhashmap无法实现，但是在看dubbo的源码的时候发现，dubbo中的lrucache就是以linkedhashmap实现的
于是了解一下原理：linkedhashmap提供构造函数传入accessorder，如果传入值为true，hashmap会在插入时检测是否达到map最大容量， 如果容量达到最大值，则将列表头部的最近最少访问
节点删除，从而实现lru
感悟：在写代码时，切勿想当然认为自己的是最好的。

redis Lru实现：
redis采用的lru为了避免构造的数据结构占用内存问题，使用随机算法选择key，进行检查最老的元素，从而进行释放。
感悟：在实际项目中，根据实际情况选择合适的策略，不一定要完整实现一个比较耗时或者耗内存的算法。



21：
参加头条面试：
部门数据平台部门，数据平台主要考察数据库的复制、redis内存问题、数据处理算法问题。
回答的不好， 继续努力吧。

22： 
docker中想要自定义网络，从而实现容器可以像宿主机一样可以局域网访问。
	在考虑这个问题的时候，发现对网络知识不是很理解，顺便复习下计算机网络的知识：https://www.cnblogs.com/maybe2030/p/4781555.html#_label2
	总结如下：
	7层网络协议: 应用层、表示层、会话层、传输层、网络层、数据链路层、物理层
	4层协议：会话层（如http， 数据传输单位为报文）、传输层（tcp 负责流控、查错管理）、网络层（ip负责路由与路由器交互）、网络接口层（数据传输单位为帧）
	arp： address resolution protocal 子网内广播，根据ip查找目标主机的mac地址， 并且本地缓存
	tcp 三次握手：
		client  --- syn ---> server
		client <--- syn + ack --- server
		client  --- ack ---> server
	tcp为啥不能二次握手：
		因为如果server的回复丢失，server将等待client的请求，从而造成资源浪费
	tcp 四次端口：
		client --- fin ---> server
		client <--- ack --- server
		client <--- fin --- server
		client --- ack ---> server
	原因：双方是平等的链接，互相确认关闭
	tcp udp: tcp是有连接的，可靠地字节流服务，udp是无连接的，不可靠的数据服务
	nat：私有地址转换成广域网ip的技术
	get post 区别：请求参数位置不同，是否幂等、传输数据不同get：2kb post：不受限制；
	gateway： 路由器的ip地址
在仔细考虑网络的问题后，本地无法与容器通信是不行的，本地需要容器中的服务时，就无法完成请求
	分析：需要容器内网络和本地网路通信；
	方案：宿主机安装docker，创建自定义网络；
		  提供ip导入功能，设置哪些ip可以用于容器分配；
		  容器启动，指定自定义网络，并且指定ip，占用ip；容器删除，释放ip；

25: 
计算机网络问题
	在解决docker网络的问题的过程中， 我发现自己对linux真的是很不了解，网卡、网桥、虚拟网卡他们如何配合工作，一点不了解。我觉得我需要重新将这块的学习一遍。
	
26:
今天把虚拟机又弄挂了一次：
	我想在56.28上搭建和测试环境一样的docker网络环境：容器可以固定和宿主机同子网的ip。
	步骤：
	1 我创建了一个docker network， 
	2 把56.28/24ip设置到对应的网桥上br-e258b14d7605， 
	3 把ens160网卡上的ip删除， 
	4 将ens160添加到br-e258b14d7605, 
	5 最后设置网桥的默认网关 192.168.56.3
	由于是远程操作linux，所以网络一定故障，就无法操作，后来联系运维恢复网络才解决，但是他们也不会用bridge模式，所以这个问题还是没有解决，心累
	运维要么把机器的权限放到业务线，要么很懂linux，比较懂网络如何配置，说到底还是公司整体技术水平不行； 
先设计下ip管理功能：
	1 导入ip功能，由于我们的ip比较分散，所以通过文本导入方式，选择文件，逐行导入
	2 表结构：id ip status
	3 选择ip功能，简单方式，通过db乐观锁直接根据状态预锁定ip，启用任务，超过10分钟预锁定状态的，释放
	4 根据docker的网络子网，选择ip，预锁定，容器创建，锁定ip，容器释放，释放ip

27:
王涛的面试题汇总：
HashMap实现原理：
	java8中在原有的 数组+链表的结构上做了改进，采用数组+链表+红黑树 当位桶的链表程度超过8则转换成红黑树，用于实现logn时间长度的查找
	在计算取模运算的时候采用(n-1) & hash 效率高于hash % (n-1)
	详细分析可以参考：https://www.cnblogs.com/xiaoxi/p/7233201.html
并发情况下资源共享问题：
	需要把握几个要点：削峰、分区、排队、写一致性 
	例如在做秒杀系统时：
		削峰：使用图形验证码限流、随机拒绝请求等操作；
		分区：将热点产品（共享资源）独立出来，例如库存可以分区分成不同的商品
		排队：同一个分区排队处理，
		写一致性：读写分离、读不做校验、写作强校验 
mysql事务问题：
	innodb的默认采用行锁，但是行锁是在索引上添加锁实现的，如果没有按照索引条件，那么会采用表锁，但是更新操作一般都是根据id来更新，所以正常都是行锁； 
    4种隔离级别： read-uncommited read-committed repetable-read(默认，可以查看select @@tx_isolation) serialable
	7种传播行为： required（加入事务或者新事务） support（加入事务或者非事务） mandotary（必须有事务） new（挂起原事务，新建新事务）never（必须非事务） not-support（挂起事务，非事务执行） nest(嵌套事务) 
Session和cookie的区别，这两者的作用：
	cookie: 是服务器存储在本地的小片文本，用于记录状态。以key/value的形式存储，有2种类：设置失效时间-permenent-存储在磁盘上；不设置时间-transient-存储在内存中-浏览器关闭删除
	session:服务器在接收到请求时生成session_id，可以将需要共享的信息放到session中，从而实现会话会话共享，session中可以存储任何java对象，通过session_id和cookie进行关联
	区别：位置不同，cookie浏览器session服务端、数据类型不同
如何实现单点登录系统: 
    跨域情况：
	通过跳转到sso系统实现登录并生成ticket；
    应用拿到ticket访问sso校验ticket，通过，写入自己的token和cookie
	同域情况：
	cookie写入一级域名下，实现cookie共享、使用session共享方案实现session共享，例如spring-sesion或者自己通过redis实现session共享； 
http和https的区别:
	
fci系统ip模块开发：
	